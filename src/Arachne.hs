{-# LANGUAGE DeriveFunctor #-}
{-# LANGUAGE EmptyCase #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE BlockArguments #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TemplateHaskell #-}
-- |
-- Module      :  Arachne
-- Copyright   :  (c) Christian Gram Kalhauge, 2020
-- License     :  BSD3
--
-- Maintainer  :  christian@kalhauge.dk
--
-- Arachne is a small semi-static site generator.
module Arachne
  (
  -- * Site Generation
  -- $sitegen
  SiteGen
  , makePage
  , makeStaticPage
  , getResource
  , getResourceOrFail

  -- ** Run SiteGen
  , createPages

  -- ** Page
  -- $page
  , Page (..)

  -- ** Route
  -- $route
  , Route (..)

  -- ** PageRef
  -- $pagerefs
  , PageRef
  , pageRelativeUrl
  , pageBaseUrl

  -- ** Utils
  -- $utils
  , serveStatic
  , serveStaticWithHash
  ) where

-- base
import Numeric
import GHC.Generics (Generic)

-- mtl
import Control.Monad.Writer

-- exceptions
import Control.Monad.Catch

-- happstack-server
import Happstack.Server

-- template-haskell
import Language.Haskell.TH
import Language.Haskell.TH.Quote

-- hashable
import Data.Hashable

-- lucid
import Lucid

-- free
import Control.Monad.Free
import qualified Control.Monad.Free.Church as F
import Control.Monad.Free.TH

-- bytestring
import qualified Data.ByteString.Lazy as BL
import qualified Data.ByteString as BS

-- filepath
import qualified System.FilePath as FilePath

-- directory
import System.Directory

-- text
import qualified Data.Text as Text

-- cryptohash-sha256
import qualified Crypto.Hash.SHA256 as SHA256 (hashlazy)

-- path
import Path

-- arachne
import Arachne.GraphT

-- $pagerefs
-- The goal

-- | A simple local url.
type LocalUrl = Path Rel File

url :: QuasiQuoter
url = relfile

-- | The basic way of refering to another page on the site.
-- It is automatically generated by the 'SiteGen'.
data PageRef = PageRef
  { pageRelativeUrl :: !LocalUrl
  -- ^ Get the relative url of a 'Route'
  , pageBaseUrl :: !(Maybe (Path Rel Dir))
  -- ^ Get the base url of a 'Route'
  } deriving (Generic)

instance Hashable PageRef

pageRefAsText :: PageRef -> Text.Text
pageRefAsText pr = Text.pack
  . fromRelFile
  . maybe id (</>) (pageBaseUrl pr)
  $ pageRelativeUrl pr

-- $route

-- | A route is a the local url to a page
data Route r where
  StaticRoute :: LocalUrl -> Route ()

parseRoute :: Route r -> LocalUrl -> Maybe r
parseRoute route url = case route of
  StaticRoute r
    | url == r  -> Just ()
    | otherwise -> Nothing

staticRoutes :: Route r -> IO [(LocalUrl, r)]
staticRoutes = \case
  StaticRoute url -> return [(url, ())]

-- $page

data PageGenF s r f
  = forall a e. Exception e => ThrowPG e (a -> f)
  | forall a. Hashable a => GetPageRef (s -> a) (a -> f)

deriving instance Functor (PageGenF s r)

makeFree_ ''PageGenF

newtype PageGen s r a = PageGen
  { unPageGen :: F.F (PageGenF s r) a
  } deriving (Functor, Applicative, Monad)

-- -- | Read a cached values
-- cachedIO ::
--   IO a
--   -> PageGen s r a

instance MonadFree (PageGenF s r) (PageGen s r) where
  wrap = PageGen . wrap . fmap unPageGen
  {-# INLINE wrap #-}

instance MonadThrow (PageGen s r) where
  throwM = throwPG
  {-# INLINE throwM #-}

-- | A page
data Page s r where
  StaticPage ::
    (PageGen s r BL.ByteString)
    -> Page s r

-- | A page with a route.
data AnchoredPage s =
  forall r. AnchoredPage (Route r) (Page s r)

-- $sitegen
-- The Site gen

newtype SiteGenerationFailed = SiteGenerationFailed String
  deriving (Show)

instance Exception SiteGenerationFailed

-- | Site Gen.
data SiteGenF s f
  = forall r. MakePage (Route r) (Page s r) ((r -> PageRef) -> f)
  | forall r. LiftGraph (GraphT IO r) (r -> f)

deriving instance Functor (SiteGenF s)

makeFree_ ''SiteGenF

newtype SiteGen s a = SiteGen
  { unSiteGen :: F.F (SiteGenF s) a
  } deriving (Functor, Applicative, Monad)

instance MonadFree (SiteGenF s) (SiteGen s) where
  wrap = SiteGen . wrap . fmap unSiteGen
  {-# INLINE wrap #-}

instance MonadResource (SiteGen s) where
  getResource = liftGraph . getResource
  {-# INLINE getResource #-}

instance MonadThrow (SiteGen s) where
  throwM = liftGraph . throwM

-- | Create a new page.
makePage ::
  Route r
  -> Page s r
  -> SiteGen s (r -> PageRef)

-- | Create a new page from a static route.
makeStaticPage ::
  LocalUrl
  -> PageGen s () BL.ByteString
  -> SiteGen s PageRef
makeStaticPage url mkPage = ($ ()) <$> makePage (StaticRoute url)
  (StaticPage mkPage)

-- | Create a new html page
makeHtmlPage ::
  Route r
  -> HtmlT (PageGen s r) ()
  -> SiteGen s (r -> PageRef)
makeHtmlPage route pageGen =
  makePage route (StaticPage $ renderBST pageGen)

-- | Create a new html page
makeStaticHtmlPage ::
  LocalUrl
  -> HtmlT (PageGen s ()) ()
  -> SiteGen s PageRef
makeStaticHtmlPage url =
  fmap ($ ()) . makeHtmlPage (StaticRoute url)

-- | Add an attribute to href
withPageRef ::
  (s -> Attribute)
  -> HtmlT (PageGen s r) ()
  -> HtmlT (PageGen s r) ()
withPageRef fn a = do
  attr <- lift (getPageRef fn)
  with a [attr]

-- | Add an attribute to href
withHref ::
  (s -> PageRef)
  -> HtmlT (PageGen s r) ()
  -> HtmlT (PageGen s r) ()
withHref fn =
  withPageRef (href_ . pageRefAsText . fn)

-- | Get a resource.
getResourceOrFail :: (MonadResource m, MonadThrow m) => Path Rel File -> m BL.ByteString
getResourceOrFail file = getResource file >>= \case
  Just bytes ->
    return bytes
  Nothing ->
    throwM $ SiteGenerationFailed ("Could not find " <> show file)


data SiteConfig = SiteConfig
  { siteBaseUrl   :: !(Maybe (Path Rel Dir))
  , siteOutput    :: !(Path Rel Dir)
  , siteResources :: !(Path Rel Dir)
  , siteCache     :: !(Path Rel Dir)
  , sitePort      :: !Int
  }

defaultConfig :: SiteConfig
defaultConfig = SiteConfig
  { siteBaseUrl = Nothing
  , siteOutput = [reldir|www|]
  , siteResources = [reldir|resources|]
  , siteCache = [reldir|.cache|]
  , sitePort = 8080
  }

getResourceIO :: SiteConfig -> Path Rel File -> IO (Maybe BL.ByteString)
getResourceIO cfg path = try (liftIO $ BL.readFile p) >>= \case
  Right bs ->
    return $ Just bs
  Left (msg :: IOError) ->
    return $ Nothing
 where
  p = fromRelFile (siteResources cfg Path.</> path)

-- | Generate a single page from a PageGen
generatePage :: SiteConfig -> s -> r -> PageGen s r a -> IO a
generatePage cfg s r (PageGen f) = flip F.iterM f \case
  ThrowPG e f ->
    throwM e
  GetPageRef fn ma ->
    ma (fn s)

-- | Creates the pages of the site.
createPages :: forall s. SiteConfig -> SiteGen s s -> GraphT IO (s, [AnchoredPage s])
createPages cfg (SiteGen f) = runWriterT $ flip F.iterM f \case
  -- LiftGraph grph mx -> do
  --   r <- lift grph
  --   mx r

  -- MakePage route gen mx -> do
  --   tell [AnchoredPage route gen]
  --   case route of
  --     StaticRoute url -> do
  --       lift $ pullG (putStrLn $ "Write" ++ show url)
  --       mx \() -> PageRef url (siteBaseUrl cfg)
  -- GetResourceSG path mx -> do
  --   mx =<< liftIO (getResourceIO cfg path)

-- | Serves the site
serveSite :: SiteConfig -> SiteGen s s -> IO ()
serveSite cfg st = do
  putStrLn $ "Creating Graph"
  let gfg = GraphConfig (siteResources cfg) (siteCache cfg)
  str <- oneShot' gfg $ do
    let x = 10
    a <- return "hello"
    return (a ++ "bind")
  print str
  -- print gfg
  -- (s, pages) <- createPages cfg st
  -- (s, pages) <- oneShot' gfg $ createPages cfg st
  -- print "Hello, yeah!"
  -- createDirectoryIfMissing True (fromRelDir $ siteOutput cfg)
  -- forM_ pages \(AnchoredPage route page) -> do
  --   routes <- staticRoutes route
  --   case page of
  --     StaticPage fn -> forM_ routes \(url, r) -> do
  --       page <- generatePage cfg s r fn
  --       BL.writeFile (fromRelFile $ siteOutput cfg </> url) page

  putStrLn $ "Starting Server at " ++ show (sitePort cfg)

  simpleHTTP nullConf { logAccess = Just logMAccess, port = sitePort cfg } $ do
    serveDirectory DisableBrowsing ["index.html"] (fromRelDir $ siteOutput cfg)


-- $utils
-- We present some utillity functions to make some operations easier.

-- | Server a static file.
serveStatic ::
  Path Rel File
  -> SiteGen s PageRef
serveStatic file = do
  bytes <- getResourceOrFail file
  makeStaticPage file (return bytes)

-- | Server a static file with hash. This allows us to cache the file in
-- the client browser. Especially good for images and scripts that do
-- not change alot.
serveStaticWithHash ::
  Path Rel File
  -> SiteGen s PageRef
serveStaticWithHash file = do
  bytes <- getResourceOrFail file
  let
    (name, exts) = FilePath.splitExtensions (fromRelFile file)
    hash = flip (foldMap showHex) "" . BS.unpack . BS.take 4 $ SHA256.hashlazy bytes
  hashedfile <- parseRelFile (name <> "_" <> hash <> exts)
  makeStaticPage hashedfile (return bytes)


data SiteRefs = SiteRefs
  { -- srIndex :: PageRef
  -- , srOther :: PageRef
  }

main :: IO ()
main = serveSite defaultConfig do
  -- srOther <- serveStatic [relfile|hello.html|]
  -- srIndex <- makeStaticHtmlPage [relfile|index.html|] do
  --   doctype_
  --   h1_ "Hello World!"
  --   p_ "This is an example code piece"
  --   withHref srIndex (a_ "index")
  --   withHref srIndex (a_ "other")

  return $ SiteRefs {}




